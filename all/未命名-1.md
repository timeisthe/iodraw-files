```mermaid
graph TD
    Start((调用端 App<br/>acquireProvider)) --> LocalCache{调用端进程<br/>是否有缓存?}
    
    %% 1. 调用端本地缓存阶段
    LocalCache -- 有 --> ReturnLocal[直接返回 IContentProvider]
    LocalCache -- 无 --> CallAMS[调用 AMS.getContentProvider]

    %% 2. AMS 决策阶段
    CallAMS --> AMSCheck{AMS 是否已记录<br/>该 Provider?}
    AMSCheck -- 是 (已发布) --> ReturnToClient[返回给调用端]
    
    AMSCheck -- 否 --> FindApp[PMS 查找目标 App 信息]
    FindApp --> ProcessCheck{目标 App 进程<br/>是否已启动?}

    %% 3. 场景 A：进程未启动
    ProcessCheck -- "A: 未启动" --> CreateRecord[创建 ContentProviderRecord<br/>调用 wait() 阻塞当前线程]
    CreateRecord --> StartProcess[AMS 启动目标 App 进程]
    
    StartProcess --> AttachApp[目标进程启动<br/>调用 AMS.attachApplication]
    AttachApp --> BindApp[AMS 回调目标进程<br/>ApplicationThread.bindApplication]
    
    subgraph TargetProcess [目标 App 进程内操作]
        BindApp --> InitProvider[反射创建 Provider 对象<br/>调用 onCreate]
        InitProvider --> SaveTargetLocal[记录到目标进程本地 Map]
        SaveTargetLocal --> Publish[调用 AMS.publishContentProviders]
    end

    Publish --> AMSNotify[AMS 记录 Provider<br/>找到 Record 调用 notifyAll]
    AMSNotify --> Resume[调用端被解除阻塞<br/>继续执行]
    Resume --> ReturnToClient

    %% 4. 场景 B：进程已启动
    ProcessCheck -- "B: 已启动" --> ScheduleInstall[AMS 调用目标进程<br/>scheduleInstallProvider]
    ScheduleInstall --> InitProvider
    
    %% 5. 最终返回阶段
    ReturnToClient --> ClientInstall[调用端 ActivityThread.installProvider<br/>存入本地 Map 缓存]
    ClientInstall --> End((获取成功))

    style CreateRecord fill:#f96,stroke:#333
    style AMSNotify fill:#f96,stroke:#333
    style TargetProcess fill:#e1f5fe,stroke:#01579b
```